# ﻿代码规范
c语言函数级别复杂度必须小于等于5，即最多嵌套5层。if、for、switch都算

当软件的代码量到了一个数量级，我们编码最困难的地方再也不是语法、算法，而是如何统帅、组织、维护它。

现代社会很少有那种一个人完成的软件了，程序员之间的沟通至关重要的，唯有好的编码风格，他人才能更容易的阅读你的代码，从而和你进行深度有效的沟通。
于是需要：使用代码格式化工具（isort等等）；PR时注意自己和他人格式；建立统一的格式文档。

在格式的笔记里面我也写道，或许你认为让代码能工作才是专业开发者的头等大事。但是实际上，修改和维护代码才是开发者花时间花得最多的地方。只有拥有良好的代码格式，代码的可读性才会增加，这对日后修改和维护产生深远影响。

设计必须简单，无论是实现还是接口。保持接口简单比保持实现简单更为重要。


天下没有免费的午餐。我以牺牲灵活性为代价，以此来减少重复代码，这算不上是一个好的权衡。例如，后来我们要求不同形状的不同手柄具备一些特殊的行为，被我重构过的代码需要修改多次才能满足需求，而原先“杂乱”的代码却可以很容易实现这些需求。

代码逻辑应该直接了当，叫缺陷难以隐藏；

尽量减少依赖关系，使之便于维护；

依据某种分层战略完善错误处理代码；

童子军军规：“让营地比你来时更干净”。

1. 一切代码与注释都是有实际意义的，没有冗余，整洁干净
2. 代码能通过所有测试，运行高效
3. 命名名副其实，区分清晰，意义明了，尽量做到看名字就能知道你的意图
4. 代码逻辑尽量直白，简单
5. 每个方法只做一件事，功能明确且单一，方法间层次分明
6. 每个类职责尽量单一，高内聚，类与类之间低耦合
7. 测试覆盖面广，每个测试用例基本只测一个点
8. 测试代码的要求与业务代码一样高


尽量解耦合；实在不行就用分层结构


整洁的代码只做好一件事；

有单元测试和验收测试；


尽量让代码易读，开发时减少读的时间。


要编写清洁代码，必须先写肮脏代码，然后再清理它
毁坏程序的最好方法之一就是以改进之名大动其结构
过早优化是万恶之源


DRY原则指的是"不要重复自己"，意思是如果代码有重复，就应该把它提炼出来。本文提出，这条原则不应过分严格地使用，有时候代码冗余对软件是有利的。

环境变量用大写字母命名，而自定义变量用小写
所有的 bash 环境变量用大写字母去命名，因此用小写字母来命名你的自定义变量以避免变量名冲突


早期的API草稿应该尽量简短，通常是类、方法签名和一行描述。这样，如果没能一次性设计好API，就可以很容易地进行重新调整。
在实现API之前，为它们编写测试用例代码，这样可以避免实现不好的API。



清楚你的优先级
代码的写法有很多种：有的运行起来很快，有的只会占用少量内存，有的更容易测试，而有的代码则有很高的可读性。
若要编写思路清晰的代码，第一步就是要将可读性放在第一位。
这也意味着势必要降低其他因素的优先级。如果把所有因素都作为最高优先级，就意味着没有优先级。




############################################################################################
有意义的命名
不同东西意义不一样时，一定要在命名上区分，如变量，不要简单的cat1，cat2这样区分


命名取名规则使得程序更易读，驼峰法：取名的时候，名字里如果有多个单词，则后面的单词的首字母要大写。

明确是王道，不要让人需要想象或者产生联想

类名是名词或名词短语，方法名是动词或者动词短语

取好名字最难的地方在于需要良好的描述技巧和共有文化背景

属性访问、修改器和断言，依Javabean标准加get、set和is前缀。如.getName(), .setName("mike");,.isPosted()



成员前缀--不必用m_表示成员前缀，应使用某种高亮或者颜色标识出成员的环境

接口和实现--不建议加接口标示I或者Interface，加实现Imp后缀好于前者


注意缩写，width/height要远好于w/h。i/j/k是专属于for循环的
错误示例：名字没有含义，a1 a2。

全局变量和局部变量，又要命名区分。例如内部函数统一加前缀“_”

把单个条目放到集合中可以用put,不要用add; 
把单个条目放大数据库中可用insert,不要用add.


############################################################################################
函数

短小，只做一件事

每个函数一个抽象层级

函数越短小，功能越集中，就越便于取个好名字

函数承诺只做一件事，但还是会做其他被藏起来的事，会导致古怪的时序性耦合及顺序依赖


分隔指令与询问：函数要么做什么事，要么回答什么事，但二者不可得兼


(最为重要的一点)函数体尽可能短小尽可能短小
一个函数只做一件事，并做好这件事。要判断函数是否只做了一件事，有一个办法是看在你编的函数里，你能否再拆出一个函数

参数名，最好和函数名有联系。这样可以，大大减轻记忆参数的负担

禁止把布尔值传入函数。因为这样做，意味着，宣称本函数不只做一件事：ture时做一件事，false时则在做另外一件事。应该将true或者false写在函数体外面。

函数的抽象层级的最高层类似于人类自然语言，使代码清晰易懂，简洁。

函数的缩进级不应该多于三层，不然就该剥离出来另一个函数了


确保每个switch都埋藏在较低的抽象层级

抽离trycatch代码块，函数返回错误码。
使用异常替代返回错误码。从指令式函数返回错误码轻微违反了指令与询问分隔的规则。鼓励了在if语句判断中把指令当做表达式使用。另一方面，如果使用异常替代返回错误码，错误处理代码就能从主路径径代码中分离出来，得到简化。
抽离Try/Catch代码块。Try/Catch代码丑陋不堪。他们搞乱了代码结构，把错误处理与正常流程混为一谈。把try和catch代码块的主体部分抽离出来，另外形成函数。函数应该只做一件事。错误处理就是一件事。因此，处理错误的函数不应该做其他的事，如果关键字try在某个函数中存在，它就应该是这个函数的第一个单词，而且在catch/fianlly代码块后面也不应该有其他内容。

相同作用的代码，抽成共用函数。

尽量避免，一元函数，一般处理event，需要有返回值。
参数要少，很多参数可以封装成对象传递。

一个方法或函数的最佳最大限制是在一个屏幕上可以容纳的行数。



优化函数
1.打磨代码，分解函数、修改名称、消除重复
2.缩短和重新安置方法、拆散类、保持测试通过



避免使用可配置函数
宁可要十个零参数的小函数，也不要一个带十个参数的函数。
诸位对类似的事一定不陌生：初始干净的函数，只在三个不同的地方被调用。而当我们想要在第四处调用时，我们需要做一点小的调整，添加一个参数。但这样第一个caller就多了一个新功能，也需要多添加两个可配置的参数。等到第五个用例，我们还要再为它添加独特的参数，以此类推。但反过来我们就又会发现第二个caller跑起来太慢了，所以只好再添加另一个参数来跳过部分繁琐的程序。




如果我只能给其他程序员一个建议，那就是编写小的代码块，你要多写小方法、小功能、小程序。我自己写C＃时，当函数接近15或20行代码时，我会感到不舒服。我的限制是，一个函数最多最多就是24行代码，因为传统终端就是24行一屏。-- 《80/24规则》



我曾在甲骨文公司工作多年，这家公司完全是销售驱动的，销售人员通常会骗客户，并保证产品具有它所没有或没有得到很好支持的功能，把产品卖出去之后，再聘请昂贵的顾问使得产品能够跟演示的一致。
如果说苹果是设计师文化，谷歌是工程师文化，那么我想说，甲骨文公司是销售文化。




############################################################################################
注释

写注释前，先仔细考虑是否可以优化代码的描述方式
别给糟糕的代码加注释——重新写吧。注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。
注释不能美化糟糕的代码。与其花时间编写解释你写出的糟糕代码的注释，还不如清洁那些糟糕的代码。


少些注释，良好的命名，就不太需要写注释。

做好判断逻辑的函数封装，可以少写注释。

程序员应当负责将注释保持在可维护、有关联、精确的高度，更应该把力气用在写清楚代码上，直接保证无须编写注释
注释的使用是为了可读性。
如果变量和函数名起得很好，常常不需要注释。（即比起注释，更重要得是一个好的变量名/函数名）

注释和代码是应是同步的

TODO注释，添加工作列表。

参数不要传null，容易空异常崩溃，还要添加判空处理。


############################################################################################
格式

如果是在团队中工作，则团队应该一致同意采用一套简单的格式规则，所有成员都要遵守，并且贯彻。使用能帮助你应用这些格式规则的自动化工具也很有帮助。
每个程序员都要自己喜欢的格式规则，但如果在一个团队中工作，就必须是团队说了算。一组开发者应当认同一种格式风格，启动项目之前制定一套编码风格，所花时间很短，却能为为以后阅读他人代码、团队合作提供了巨大的便捷。


修改和维护代码才是开发者花时间花得最多的地方。只有拥有良好的代码格式，代码的可读性才会增加，这对日后修改和维护产生深远影响。

源文件最顶部应该给出高层次概念和算法，细节应该往下渐次展开。最上面的代码应该是最抽象的，底部细节应该在下面实现。这样就能像报纸文章一样，最重要的概念在最前面，底部细节最后才会出来。


在不同的思路之间的代码以空白号/空白行为分隔。
靠近的代码行则暗示了他们之间的紧密关系，紧密相关的代码应该相互靠近。
若某个函数调用另一个，就应当把他们放在一起。


############################################################################################
类
类应该从一组变量列表开始。如果有公共静态常量，应该先出现。然后是私有静态变量，以及私有实体变量。很少会有公共变量（尽量可能公共变量的数量）。
系统的每次修改都需要review。我们知道编写一个类不是一触而就的，而是通过了无数次修进的。而系统的每处修改（添加功能，改变逻辑方法等）都让我们冒着系统会出现问题的风险。这时候我们要对类加以修进（组织和重构），以降低修改所面临的风险。
当一个类庞杂巨大需要重构的时候，将一个类分隔为几个类，用明确的功能权责来划分。


############################################################################################
对象和数据结构

数据、对象的反对称性
过程式代码难以添加新的数据结构，因为这要修改所有相关函数；面向对象代码难以添加新函数，因为要修改所有相关类

避免混杂，对象和数据结构要分开。




迪米特法则（Law of Demeter）又叫作最少知识原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。英文简写为: LoD.
如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的业务逻辑无关。

依赖倒置原则（Dependency Inversion Principle,DIP），类应该依赖于抽象而不是依赖于具体细节

############################################################################################
单元测试
TDD三定律

1.在编写能通过的单元测试前，不可编写生产代码(测试先行)。测试应该及时编写。单元测试，应该恰好在使其通过的生产代码之前编写。

2.只可编写刚好无法通过的单元测试，不能编译也算不通过(测试一旦失败，开始写生产代码)

3.只可编写刚好足以通过当前失败测试的生产代码(老测试一旦通过，返回写新测试)

快速。测试不应该过于缓慢，如果测试过于缓慢，你就会不想频繁的测试，如果你不频繁运行测试，就不能尽早发现问题。代码将腐化。


可重复。测试应当可在任何反应中重复通过。


测试应该相互独立，每一个测试用例只测试一个功能，不会相互依赖。每个测试一个断言。每个测试中的断言，要尽可能少！不能把不同的测试放在一起。

测试应该有布尔值输出，自己就能给出对错，而不需要通过看日志，比对结果等方式验证。这样比较简单易懂，并且一旦完成测试代码就不用管了。
自足验证。测试的结果应该明显，最好是bool值，不应通过查看日志这种低效率的方法来判断测试是否通过。应当由程序来判断。


保持测试代码的整洁。不要以为只是测试就不写整洁的代码，脏测试等同于没测试。
异常处理需要添加开关，可以选择处理异常，也可以不处理。


测试代码与生产代码的不同
1）测试代码应当简单精悍足具表达力。有些事你大概永远不会在生产环境中做，而在测试环境中做却完全没问题。通常这关乎内存和upu效率的问题(比方要求在多少秒内，内存不应该超过多少多少)。
2）这是代码应该极具阅读性。


############################################################################################
并发编程
常见的迷思和误解

* 并发总能改进性能：只在多个线程或处理器之间能分享大量等待时间的时候管用

* 编写并发程序无需修改设计：可能与单线程系统的设计极不相同

* 在采用web或ejb容器时，理解并发问题并不重要

有关编写并发软件的中肯的说法

* 并发会在性能和编写额外代码上增加一些开销

* 正确的并发是复杂的，即使对于简单的问题也是如此

* 并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待

* 并发常常需要对设计策略的根本性修改


测试线程代码
先使非线程代码可工作：不要同时追踪非线程缺陷和线程缺陷，确保代码在线程之外可工作
运行多于处理器数量的线程：任务交换越频繁，越有可能找到错过临界区域导致死锁的代码
在不同平台上运行：尽早并经常地在所有目标平台上运行线程代码




############################################################################################
系统
如何建造一个城市
1.每个城市都有一组人管理不同的部分，有人负责全局，其他人负责细节
2.深化出恰当的抽象等级和模块，好让个人和他们所管理的“组件”即便在不了解全局时也能有效地运转


将系统的构造与使用分开

将构造与使用分开的方法之一是将全部构造过程搬迁到main或被称为main的模块中，设计系统的其余部分时，假设所有对象都已正确构造和设置


############################################################################################
重构
函数圈复杂度应该小于10。所谓函数圈复杂度：
一旦遇到以下关键字，或者其它同类词加1（if/for/while/and/or）；给case语句中的每一种情况加1；三元运算符a?b:c 加1；给try catch语句加1


尽量减少for循环，for循环太多影响效率







"一开始就做对系统"纯属神话，反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事，这就是迭代和增量敏捷的精髓所在。
