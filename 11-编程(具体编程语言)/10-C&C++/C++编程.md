# C++编程


------------------------------------------------------------------------------------------------------
explicit是个C++关键字，explicit可以抑制内置类型隐式转换,所以在类的构造函数中,最好尽可能多用explicit关键字,防止不必要的隐式转换。
用了的话，对类进行直接赋值会被提示错误，即构造函数必须显式初始化




------------------------------------------------------------------------------------------------------
thread_local
在必要的情况下，我们可以为每个线程创建线程本地数据。 线程局部数据专属于线程，其行为类似于静态数据。 



------------------------------------------------------------------------------------------------------
Lambda函数很简洁，但变化较多。
Lambda函数的语法定义如下：
[capture](parameters) mutable ->return-type{statement}



------------------------------------------------------------------------------------------------------
Malloc函数和new
Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。
当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并

申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。

new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。

------------------------------------------------------------------------------------------------------
堆和栈的区别
1）申请方式：栈由系统自动分配和管理，堆由程序员手动分配和管理。
2）效率：栈由系统分配，速度快，不会有内存碎片。堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。
3）扩展方向：栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。
4）程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间。





------------------------------------------------------------------------------------------------------
段错误通常发生在访问非法内存地址的时候，具体来说分为以下两种情况：使用野指针；试图修改字符串常量的内容



------------------------------------------------------------------------------------------------------
C++11 最常用的新特性如下：
auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导
nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。
智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。
初始化列表：使用初始化列表来对类进行初始化
右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
atomic原子操作用于多线程资源互斥操作
新增STL容器array以及tuple


------------------------------------------------------------------------------------------------------
setw() 函数来格式化输出


------------------------------------------------------------------------------------------------------
sizeof 是运算符，strlen 是函数。

------------------------------------------------------------------------------------------------------
在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。常常使用系统时间来初始化
srand( (unsigned)time( NULL ) );
rand();


------------------------------------------------------------------------------------------------------
C++中引用 vs 指针，引用很容易与指针混淆，它们之间有三个主要的不同：
不存在空引用。引用必须连接到一块合法的内存。
一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
引用必须在创建时被初始化。指针可以在任何时间被初始化。


------------------------------------------------------------------------------------------------------
类与结构体在 C++ 中只有两点区别，除此这外无任何区别。
（1）class 中默认的成员访问权限是 private 的，而 struct 中则是 public 的。
（2）从 class 继承默认是 private 继承，而从 struct 继承默认是 public 继承。
（3）class 可以定义模板，而 struct 不可以。



------------------------------------------------------------------------------------------------------
如果继承时不显示声明是 private，protected，public 继承，则默认是 private 继承，在 struct 中默认 public 继承。
private 成员只能被本类成员（类内）和友元访问，不能被派生类访问。
protected 成员可以被派生类访问。保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。



------------------------------------------------------------------------------------------------------
在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。




------------------------------------------------------------------------------------------------------
Line::Line(int len)
{
    cout << "调用构造函数" << endl;
    // 为指针分配内存
    ptr = new int;
    *ptr = len;
}






------------------------------------------------------------------------------------------------------
拷贝构造函数
当类的对象用于函数值传递时（值参数，返回类对象），拷贝构造函数会被调用。如果对象复制并非简单的值拷贝，那就必须定义拷贝构造函数。简而言之，当数据成员中有指针时，必须要用深拷贝；而编译器会默认生成一个浅拷贝的拷贝构造函数。
浅拷贝就是指向同一个地址；深拷贝就是新开辟一个空间用于存储，也就是指向了两个不同的地址。为了克服浅拷贝的不足，用户必须给出显式的拷贝构造函数，以实现“深拷贝”的功能。
例如：Point(const Point &p)；String(const String &other);

拷贝赋值函数，即重载赋值操作符“=”
复制构造函数是构造函数，而赋值操作符属于操作符重载范畴，它通常是类的成员函数
A & operator = (const A &a)；String & operator=(const String &other);






------------------------------------------------------------------------------------------------------
尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数（友元类）。
友元的唯一用法就是实现非成员函数访问类的私有成员，其他时候一定不要用，这破坏了封装性(OOP的三大特性)。
友元将类的私有成员暴露出来，在c++中友元函数是为了实现非成员函数访问类的私有成员而声明的一种函数。这样会破坏了类的封装性。





------------------------------------------------------------------------------------------------------
环状继承,A->D, B->D, C->(A，B)
这个继承会使D创建两个对象,要解决上面问题就要用虚拟继承格式
格式：class 类名: virtual 继承方式 父类名

------------------------------------------------------------------------------------------------------
多重继承
从最远端的开始调用构造，从本身开始掉析构

我们几乎不使用 protected 或 private 继承，通常使用 public 继承。

继承时，构造函数和析构函数的调用顺序
继承时，构造函数和析构函数的调用顺序
1. 先调用父类的构造函数，再初始化成员，最后调用自己的构造函数
2.先调用自己的析构函数，再析构成员，最后调用父类的析构函数
3.如果父类定义了有参数的构造函数，则自己也必须自定义带参数的构造函数
4.父类的构造函数必须是参数列表形式的
5.多继承时，class D: public Base2, Base1, Base的含义是：class D: public Base2, private Base1, private Base，而不是class D: public Base2, public Base1, public Base
6.多继承时，调用顺序取决于class D: public Base2, public Base1, public Base的顺序，也就是先调用Base2,再Base1，再Base。但是有虚继承的时候，虚继承的构造函数是最优先被调用的。


------------------------------------------------------------------------------------------------------
静态成员和静态成员函数
可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本（即静态成员变量只有一份，被所有同类对象共享）。访问静态成员时，可以通过“对象名.成员名”，也可以通过“类名::成员名”的方式访问，不需要指明被访问的成员属于哪个对象或作用于哪个对象。因此，甚至可以在还没有任何对象生成时就访问一个类的静态成员（静态成员函数并不需要作用在某个具体的对象上，因此本质上是全局函数）。
静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下：<数据类型><类名>::<静态数据成员名>=<值>

设置静态成员的目的，是为了将和某些类紧密相关的全局变量和全局函数写到类里面，形式上成为一个整体。
不能把静态成员的初始化放置在类的定义中。
如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态成员函数只要使用类名加范围解析运算符 :: 就可以访问。静态成员函数不接受隐含的this自变量。所以，它就无法访问自己类的非静态成员。
静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。


友元不是成员函数


------------------------------------------------------------------------------------------------------
重载 Overload
表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。
运算符重载，例如：Box operator+(const Box& b)

重写 Override，即覆盖
重写的基类中被重写的函数必须有virtual修饰，不能是static的。
表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。
在继承中，基类的虚函数不希望被override(重写)。例如virtual void Fun() final。多态行为的基础

重定义 (redefining)也叫做隐藏，子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) 。
重写与重定义的区别：使用virtual关键字声明之后能够产生多态（如果不使用virtual，那叫重定义）；多态行为的基础




------------------------------------------------------------------------------------------------------
多态（polymorphism）
不使用virtual，则是静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。
虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。
想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。即声明一个“=0”的虚函数。

如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。抽象类不能被实例化，它只能作为父类被继承。



父类的虚函数或纯虚函数在子类中依然是虚函数。有时我们并不希望父类的某个函数在子类中被重写，在 C++11 及以后可以用关键字 final 来避免该函数再次被重写。
如果不希望一个类被继承，也可以使用 final 关键字。
class Class_name final
{
}



------------------------------------------------------------------------------------------------------
抽象类和接口有区别
接口是一个概念。它在C++中用抽象类来实现，在C#和Java中用interface来实现。
抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。
封装好的就是接口
抽象类不能被用于实例化对象，它只能作为接口使用。
设计策略：面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。
接口不变(暴露的虚函数不变)，而该基类的子类的具体实现会变化


------------------------------------------------------------------------------------------------------
C++中, 虚函数可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。
一个成员函数被定义为private属性，标志着其只能被当前类的其他成员函数(或友元函数)所访问。而virtual修饰符则强调父类的成员函数可以在子类中被重写，因为重写之时并没有与父类发生任何的调用关系，故而重写是被允许的。
C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。







------------------------------------------------------------------------------------------------------
try和throw以及catch是异常处理的关键字；用得少，用在大型项目中或者需要统一抛出异常的时候(即对方将所有代码视为整体)，例如王臻的pc抛异常


------------------------------------------------------------------------------------------------------



------------------------------------------------------------------------------------------------------
二维数组：要new一个数组指针，要delete两层
'''
array = new int *[m];
for(int i=0; i<=m; i++)
{
    delete [] arrary[i];
}
delete [] array;
'''

三维数组：要delete三层
array = new int **[m];

如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。


------------------------------------------------------------------------------------------------------
template
模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。
模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器(是类模板)和算法，都是泛型编程的例子，它们都使用了模板的概念。
类模板：template <class T> (后面接正常的class定义)
函数模板：template <typename identifier> 
定义多个类型的模板：template<class T1, class T2>



------------------------------------------------------------------------------------------------------

typedef
typedef相当于别名，用途有在纯c中帮助struct；用typedef来定义与平台无关的类型；为复杂的声明定义一个新的简单的别名。
typedef 与 #define的区别：通常讲，typedef要比#define要好，特别是在有指针的场合。根本原因就在于#define只是简单的字符串替换而typedef则是为一个类型起新名字。







------------------------------------------------------------------------------------------------------
请你说一说进程和线程的区别
参考回答：
1）进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。
2）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。
3）一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。
4）进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。进程切换需要分两步：切换页目录、刷新TLB以使用新的地址空间；切换内核栈和硬件上下文（寄存器）；而同一进程的线程间逻辑地址空间是一样的，不需要切换页目录、刷新TLB。
5）进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易。








------------------------------------------------------------------------------------------------------
软链接和硬链接区别
若1个inode号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名,使用ln创建。硬链接文件和源文件的大小和创建时间一样。硬链接文件的内容和源文件的内容一模一样，相当于copy了一份（但物理上并没有真正copy，copy的是inode）。注意删除源文件后，硬链接文件还可以查看的哦，因为inode号还在。
若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的inode,但是其数据块内容比较特殊。


------------------------------------------------------------------------------------------------------
大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。


------------------------------------------------------------------------------------------------------
静态变量什么时候初始化
静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造







------------------------------------------------------------------------------------------------------
内存溢出和内存泄漏
1、内存溢出
指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误

内存溢出原因：

内存中加载的数据量过于庞大，如一次从数据库取出过多数据

集合类中有对对象的引用，使用完后未清空，使得不能回收

代码中存在死循环或循环产生过多重复的对象实体

使用的第三方软件中的BUG

启动参数内存值设定的过小

2、内存泄漏

内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

内存泄漏的分类：

1、堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。

2、系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。



------------------------------------------------------------------------------------------------------
野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针


------------------------------------------------------------------------------------------------------
智能指针
使用普通指针存在：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。
普通指针是通过Malloc分配内存，free释放内存
智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。


C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。
unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。
C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。
当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。


------------------------------------------------------------------------------------------------------
虚函数 析构函数
C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。
基类指针可以指向派生类的对象（多态性），如果删除该指针delete []p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。所以，将析构函数声明为虚函数是十分必要的。



函数指针与虚函数表
__vfptr只是一个指针, 她指向一个函数指针数组(即: 虚函数表)
增加一个虚函数, 只是简单地向该类对应的虚函数表中增加一项而已, 并不会影响到类对象的大小以及布局情况


静态函数和虚函数的区别
静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销


多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。
静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销





------------------------------------------------------------------------------------------------------
i++ 实现：
const int  int::operator（int）
{
int oldValue = *this；
++（*this）；
return oldValue；
}


在main函数执行前先运行
__attribute__((constructor))void before()
{
    printf("before main\n");
}








