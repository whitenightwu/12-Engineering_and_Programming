**********************************************************************************************
7． printf (“%d%d\n”,++n, power(2,n)); 其中power(2,n)为实现一定功能的函数 如 2^n 。 
    请问这种表示方法有什么潜在的问题？ 
 

答案：编译器的不同，对++n 和power(2,n)处理的先后顺序不一样，形成二义性，造成程 序的移植性差，因此最好把++n 写在printf函数外面，以消除二义性。


**********************************************************************************************
8.
#pragma pack(8)  
  
struct s1{   
short a; 2  
long b;  4 }; 
 
  

struct s2{   
char c; 1byte  
s1 d;   8
long long e;  8 }; 
 
  
#pragma pack()  
  

问  
  1.sizeof(s2) =   
  2.s2的s1中的a后面空了几个字节接着是b 

答案就是24和3
成员对齐有一个重要的条件,即每个成员分别对齐.即每个成员按自己的方式对齐.   
也就是说上面虽然指定了按8字节对齐,但并不是所有的成员都是以8字节对齐.其对齐的规则是,每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数(这里是8字节)中较小的一个对齐.并且结构的长度必须为所用过的所有对齐参数的整数倍,不够就补空字节.  
  
S1中,成员a是1字节默认按1字节对齐,指定对齐参数为8,这两个值中取1,a按1字节对齐;成员b是4个字节,默认是按4字节对齐,这时就按4字节对齐,所以sizeof(S1)应该为8; 
  

S2中,c和S1中的a一样,按1字节对齐,而d 是个结构,它是8个字节,它按什么对齐呢 对于结构来说,它的默认对齐方式就是它的所有成员使用的对齐参数中最大的一个,S1的就是4.所以,成员d就是按4字节对齐.成员e是8个字节,它是默认按8字节对齐,和指定的一样,所以它对到8字节的边界上,这时,已经使用了12个字节了,所以又添加了4个字节的空,从第16个字节开始放置成员e.这时,长度为24,已经可以被8(成员e按8字节对齐)整除.这样,一共使用了24个字节.   

a b 
  
S1的内存布局：11**,1111,   
c S1.a S1.b d 
  
S2的内存布局：1***,11**,1111,****11111111  
  
这里有三点很重要: 
  1.每个成员分别按自己的方式对齐,并能最小化长度 
  2.复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式,这样在成员是复杂类型时,可以最小化长度 
  3.对齐后的长度必须是成员中最大的对齐参数的整数倍,这样在处理数组时可以保证每一项都边界对齐



**********************************************************************************************
4. static有什么用途？（请至少说明两种） 

1.限制变量的作用域 
2.设置变量的存储域


**********************************************************************************************
7. 引用与指针有什么区别？  
1) 引用必须被初始化，指针不必。  
2) 引用初始化以后不能被改变，指针可以改变所指的对象。 
3) 不存在指向空值的引用，但是存在指向空值的指针。


**********************************************************************************************
9. 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？ 
全局变量储存在静态数据库，局部变量在堆栈


**********************************************************************************************
11. 堆栈溢出一般是由什么原因导致的？ 
没有回收垃圾资源


12. 什么函数不能声明为虚函数？ 
constructor 


14. 写出float x 与“零值”比较的if语句。 
if(x>0.000001&&x<-0.000001) 

16. Internet采用哪种网络协议？该协议的主要层次结构？ 
tcp/ip 应用层/传输层/网络层/数据链路层/物理层 

17. Internet物理地址和IP地址转换采用什么协议？ 
ARP (Address Resolution Protocol)（地址解析fh） 




**********************************************************************************************
排序算法的时间复杂度:
选择排序：不稳定，时间复杂度 O(n^2)
插入排序：稳定，时间复杂度 O(n^2) 
冒泡排序：稳定，时间复杂度 O(n^2) 
堆排序：不稳定，时间复杂度 O(nlog n)
归并排序：稳定，时间复杂度 O(nlog n)
快速排序：不稳定，时间复杂度 最理想 O(nlogn) 最差时间O(n^2)
希尔排序：不稳定，时间复杂度 平均时间 O(nlogn) 最差时间O(n^s) 1<s<2



**********************************************************************************************
18.IP地址的编码分为哪俩部分？ 

IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。

A类   0~126      8位       24位 1.0.0.0---126.0.0.0	
	由1字节（每个字节是8位）的网络地址和3个字节主机地址组成，网络地址的最高位必须是“0”,例如： 一台主机的ip地址为5.6.7.8，那么该主机所在的网络地址就是5.0.0.0；而全1表示“所有的”，因为全1的主机号字段表示该网络上的所有主机），Internet有126个可用的A类网络。IP地址空间共有2^32个，整个A类地址共有2^31个，占整个IP地址空间的50%.一个A类网络可提供的主机地址为16777214个，也就是2^24-2个

B类  128~191  16位       16位 	172.16.0.0---172.31.255.255	
	B类地址默认子网掩码为255.255.0.0,网络地址的最高位必须是“10”，即第一段数字范围为128～191。每个B类地址可连接65534(256*256-2, 因为主机号的各位不能同时为0,1)台主机

C类  192~223  24位       8位 	192.0.0.0---223.255.255.0
	C类地址第1\2\3字节为网络地址，第4个字节为主机地址。第1个字节的前三位固定为110。
	每个C类地址可连接254台主机（0是网络号不可用， 255是广播地址，除去这2个，可用的就是254个地址），Internet有2097152个C类地址段（32*256*256），有532676608个地址（32*256*256*254）。

D类  224~239  组播地址 
E类   240~255  保留试验使用 



**********************************************************************************************
3.不能做switch()的参数类型是： 
switch的参数不能为实型。
因为switch后面只能带自动转换为整形(包括整形)的类型,比如字符型char，unsigned int等,实数型不能自动转换为整形.
C/C++中： 
支持byte,char,short,int,long,bool,整数类型和枚举类型。 
不支持float，double，string

4、局部变量能否和全局变量重名？ 

答：能，局部会屏蔽全局。要用全局变量，需要使用"::" 

5、如何引用一个已经定义过的全局变量？ 
答：extern 
可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错 

3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？ 
答：可以，在不同的C文件中以static形式来声明同名全局变量。 
可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错 


4、语句for( ；1 ；)有什么问题？它是什么意思？ 
答：和while(1)相同


**********************************************************************************************
22、请写出下列代码的输出内容 
#include main() { 

int a,b,c,d; 
a=10; 
b=a++; 
c=++a; 

d=10*a++; 

printf("b，c，d：%d，%d，%d"，b，c，d）; return 0; } 

答：10，12，120

d=10*a++ 
10*a赋值给d,则d==120
然后a++,a==13


**********************************************************************************************
7、请找出下面代码中的所以错误 
说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”  


X1、#include"string.h" 
X2、main() 
3、{ 

4、 char*src="hello,world"; 
5、 char* dest=NULL; 

6、 int len=strlen(src); 
X7、 dest=(char*)malloc(len); 
8、 char* d=dest; 

X9、 char* s=src[len]; 
10、 while(len--!=0) 
X11、 d++=s--; 

X12、 printf("%s",dest); 
13、 return 0; 
14、} 

答： 方法1： 
int main() // 后面return 0；这里应该是 int main()
{ 
char* src = "hello,world"; 
char* dest=NULL; 
int len = strlen(src); 

char* dest = (char*)malloc(len+1);//要为分配一个空间 
char* d = dest; 

char* s = &src[len-1];//指向最后一个字符 
//src[len]是char类型，不能赋值给char*类型的s 要指向地址 减1 为了不把结束符直接赋值给dest第一位

while( len-- != 0 ) 
*d++=*s--; 

*d = 0;//尾部要加 
printf("%s\n",dest); 

free(dest);// 使用完，应当释放空间，以免造成内存汇泄露 
return 0; }



**********************************************************************************************
A、HTTP B、SMTP C、TCP D、IP哪个是网络层协议

A:HTTP 应用层
B:SMTP 应用层
C:TCP 传输层
D:IP 网络层


程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。


**********************************************************************************************
3.以下是求一个数的平方的程序,请找出错误:
#define SQUARE(a)((a)*(a))
int a=5;
int b;
b=SQUARE(a++);


对。
#define SQUARE(a)((a)*(a))
是一个宏，是严格按照文本展开的

b=SQUARE(a++); 被展开后变成了：b=(a++)*(a++);
这已经偏离了设计之初的本意。因为参数a被传入后，实际会因为++的自加操作导致参数发生变化
这个应该用函数实现。 
不过我在Visual Studio下编译了运行倒是25

经过预处理器处理后，代码变成了int b = (a++)*(a++);也就是下面那个代码的形式，
而C标准并未规定编译器在一个表达式中何时进行自增运算，故结果可能是5*5(先把a取出，最后进行两次自增），也可能是（5*6）（先取出第一个a，自增后取出第二个a），输出25说明你的编译器采用了前面那种方式罢了。一个表达式中多个自增运算与编译器有关。
所以建议不要在同一个表达式中对同一变量施行多次自增运算


**********************************************************************************************
4.以下是求一个数的平方的程序,请找出错误:
typedef unsigned char BYTE 

int examply_fun(BYTE gt_len; BYTE *gt_code) 
{ 
BYTE *gt_buf; 

gt_buf=(BYTE *)MALLOC(Max_GT_Length);
 ...... 

if(gt_len>Max_GT_Length) 
{ 
return GT_Length_ERROR; } 

....... }

没有释放空间

**********************************************************************************************
1．进程和线程的差别。 

线程是指进程内的一个执行单元,也是进程内的可调度实体. 
与进程的区别: 

(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 

(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. 
(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。




4.上述三个有什么区别？ 

char * const p; //常量指针，p的值不可以修改 

char const * p；//指向常量的指针，指向的常量值不可以改 
const char *p； //和char const *p



**********************************************************************************************
main() { 

int a[5]={1,2,3,4,5}; 
int *ptr=(int *)(&a+1);  

printf("%d,%d",*(a+1),*(ptr-1)); } 

输出：2,5 


*(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5 

&a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）
int *ptr=(int *)(&a+1); 
则ptr实际是&(a[5]),也就是a+5 

原因如下： 
&a是数组指针，其类型为 int (*)[5]; 
而指针加1要根据指针类型加上一定的值， 
不同类型的指针+1之后增加的大小不同 
a是长度为5的int数组指针，所以要加 5*sizeof(int) 所以ptr实际是a[5] 

但是prt与(&a+1)类型是不一样的(这点很重要) 
所以prt-1只会减去sizeof(int*) 
a,&a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，
&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5].


**********************************************************************************************
3、关键字static的作用是什么？ 
定义静态变量  


静态局部变量和全局变量的同异
都生存于整个程序；作用域不同

全局变量与全局静态变量的区别： 
 (a）若程序由一个源文件构成时，全局变量与全局静态变量没有区别。 
 (b)若程序由多个源文件构成时，全局变量与全局静态变量不同：全局静态变量使得该变量成为定义该变量的源文件所独享，即：全局静态变量对组成该程序的其它源文件是无效的。 
 (c)具有外部链接的静态；可以在所有源文件里调用；除了本文件，其他文件可以通过extern的方式引用；
静态全局变量的作用： 
（a）不必担心其它源文件使用相同变量名，彼此相互独立。
（b）在某源文件中定义的静态全局变量不能被其他源文件使用或修改。
 (c) 只能在本文件中使用！具有内部链接的静态；不允许在其他文件里调用；


4、关键字const有什么含意？  
表示常量不可以修改的变量。  

5、关键字volatile有什么含意？并举出三个不同的例子？ 
提示编译器对象的值可能在编译器未监测到的情况下改变。    
int (*s[10])(int) 表示的是什么啊  
int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。

6.交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3; 
有两种解法, 
一种用算术算法, 一种用^(异或) 
a = a + b; 
b = a - b; 
a = a - b; 

or 

a = a^b;// 只能对int,char.. 
b = a^b; 
a = a^b; 

or 

a ^= b ^= a;



**********************************************************************************************
3.c和c++中的struct有什么不同？ 










c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。
c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private

8.类的静态成员和非静态成员有何区别？ 

类的静态成员每个类只有一个，非静态成员每个对象一个 

9.纯虚函数如何定义？使用时应注意什么？ 










virtual void f()=0; 

是接口，子类必须要实现 

10.数组和链表的区别 

数组：数据顺序存储，固定大小 

连表：数据可以随机存储，大小可动态改变

1：(void *)ptr 和 (*(void**))ptr的结果是否相同？其中ptr为同一个指针 
.(void *)ptr 和 (*(void**))ptr值是相同的 

2：int main() { 
int x=3; printf("%d",x); return 1;  
} 

问函数既然不会被其它函数调用，为什么要返回1？ 

main中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息



**********************************************************************************************
unsigned short A = 10; 
printf("~A = %u\n", ~A);  

char c=128; 

printf("c=%d\n",c);  
输出多少？并分析过程 


第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285 
第二题，c＝0x10,输出的是int，最高位为1，是负数，
所以它的值就是0x00的补码就是128，所以输出－128。


**********************************************************************************************
分析下面的程序： 

void GetMemory(char **p,int num) { 
*p=(char *)malloc(num);  } 

int main() 
{ 
char *str=NULL;  

GetMemory(&str,100); 









 

strcpy(str,"hello");  

free(str);  

if(str!=NULL) { 
strcpy(str,"world"); }  

printf("\n str is %s",str); 
getchar(); 
} 

问输出结果是什么？希望大家能说说原因，先谢谢了

 
输出str is world。 

free 只是释放的str指向的内存空间,它本身的值还是存在的. 

所以free之后，有一个好的习惯就是将str=NULL. 

此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的, 
尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。 
这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。 当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的，只不过。。。。。。。
。楼上都说过了，最好别这么干。



**********************************************************************************************
long a=0x801010; 
a+5=  

0x801010用二进制表示为：“1000 0000 0001 0000 0001 0000”，十进制的值为8392720，再加上5就是8392725罗 


**********************************************************************************************
char a[10],strlen(a)为什么等于15？

sizeof()和初不初始化，没有关系； 
strlen()和初始化有关。

strlen(char*)函数求的是字符串的实际长度，它求得方法是从开始到遇到第一个'\0',如果你只定义没有给它赋初值，这个结果是不定的，它会从aa首地址一直找下去，知道遇到'\0'停止。
EX:
 char aa[10];cout<<strlen(aa)<<endl; //结果是不定的
 char aa[10]={'\0'}; cout<<strlen(aa)<<endl; //结果为0
 char aa[10]="jun"; cout<<strlen(aa)<<endl; //结果为3

而sizeof()函数返回的是变量声明后所占的内存数，不是实际长度。

**********************************************************************************************
struct A 
{ 
char t:4; 
char k:4; 
unsigned short i:8; 
unsigned long m; 
} 
sizeof(A)= （不考虑边界对齐）这个结果为什么会是7？考虑边界应该是8

char t:4; char类型在内存中占用1个字节，但是它在内存中只占用了4位
char k:4; char类型在内存中占用1个字节，但是它在内存中只占用了4位
所以两个char型只占用了1个字节，
unsigned short i:8; short类型占用2个字节，在结构体中只用了8位，也就是实际在内容空间中使用了1个字节，但是需要1个字节的填充字节
unsigned long m; long类型占用4个字节

最后结果是：sizeof(A)=1+1+1+4=7  不考虑边界
考虑边界应该是8


**********************************************************************************************
#include<iostream>
using namespace std;
#include<string.h>
typedef struct AA
{
int b1:5;
int b2:2;
}AA;
void main()
{
AA aa;
cout<<sizeof(AA)<<endl;
char cc[100];
cout<<strlen(cc)<<endl;
strcpy(cc,"0123456789abcdefghijklmnopqrstuvwxyz");
memcpy(&aa,cc,sizeof(AA));
cout << aa.b1 <<endl;
cout << aa.b2 <<endl;
}
输出结果是多少？

首先sizeof(AA)的大小为4,b1和b2分别占5bit和2bit. 
经过strcpy和memcpy后,aa的4个字节所存放的值是: 0,1,2,3的ASC码，
即00110000,00110001,00110010,00110011 
所以，最后一步：显示的是这４个字节的前５位，和之后的２位分别为：10000,和01 

因为int是有正负之分-16 1

简单说结果怎么来的,把str变量cc的存储信息(二进制码)拷贝到结构变量aa的内存中(5bit的b1和2bit的
b2),0的二进制ascii码是00110000(48,用win自带计算器自己转换一下),
b1得后五位10000,b2得接下来的两位01(倒着取,顺着排),
b1是符号int,所以是-16,b2是无符号int,所以是1



**********************************************************************************************
下面这个程序执行后会有什么错误或者效果:
 #define MAX 255 
int main() { 










unsigned char A[MAX],i;//i被定义为unsigned char 
for (i=0;i<=MAX;i++) 
A[i]=i; } 


解答：死循环加数组越界访问（C/C++不进行数组越界检查） 
MAX=255 

数组A的下标范围为:0..MAX-1,这是其一.. 
其二.当i循环到255时,循环内执行: A[255]=255; 

这句本身没有问题..但是返回for (i=0;i<=MAX;i++)语句时, 

由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.



**********************************************************************************************
1）读文件file1.txt的内容（例如）： 12 
34 56 

输出到file2.txt： 56 34 12 
（逆序） 


第一题,注意可增长数组的应用. 
#include  
#include  









 

int main(void) { 

int MAX = 10; 

int *a = (int *)malloc(MAX * sizeof(int)); 
int *b;  

FILE *fp1; 
FILE *fp2;  

fp1 = fopen("a.txt","r"); 
if(fp1 == NULL) {printf("error1"); exit(-1); }  

fp2 = fopen("b.txt","w"); 
if(fp2 == NULL) {printf("error2"); exit(-1); } 
 


int i = 0; 
int j = 0;  

while(fscanf(fp1,"%d",&a[i]) != EOF) 
{ 
i++; j++; 

	if(i >= MAX) 
	{ 	
MAX = 2 * MAX; 

		b = (int*)realloc(a,MAX * sizeof(int)); 
		if(b == NULL) { 
printf("error3"); exit(-1); } 

		a = b; 
	} 
} 
 


for(;--j >= 0;) 
fprintf(fp2,"%d\n",a[j]); 









 

fclose(fp1); 
fclose(fp2);  

return 0;   }  


**********************************************************************************************
兄弟,这样的题目若是做不出来实在是有些不应该, 给你一个递规反向输出字符串的例子,可谓是反序的经典例程.  

void inverse(char *p) { 
if( *p = = '' ) 
return; 

inverse( p+1 ); 

printf( "%c", *p ); }  


int main(int argc, char *argv[]) { 

inverse("abc");  

return 0; 
}  




借签了楼上的“递规反向输出” 

#include  

void test(FILE *fread, FILE *fwrite) {
 
char buf[1024] = {0}; 

if (!fgets(buf, sizeof(buf), fread)) 
return; 

test( fread, fwrite ); 
fputs(buf, fwrite); 
} 


int main(int argc, char *argv[]) { 

FILE *fr = NULL; 
FILE *fw = NULL; 

fr = fopen("data", "rb"); 
fw = fopen("dataout", "wb"); 
test(fr, fw); 
fclose(fr); fclose(fw); return 0; }




**********************************************************************************************


**********************************************************************************************
3.以下是求一个数的平方的程序,请找出错误:
#define SQUARE(a)((a)*(a))
int a=5;
int b;
b=SQUARE(a++);


对。
#define SQUARE(a)((a)*(a))
是一个宏，是严格按照文本展开的

b=SQUARE(a++); 被展开后变成了：b=(a++)*(a++);
这已经偏离了设计之初的本意。因为参数a被传入后，实际会因为++的自加操作导致参数发生变化
这个应该用函数实现。 
不过我在Visual Studio下编译了运行倒是25

经过预处理器处理后，代码变成了int b = (a++)*(a++);也就是下面那个代码的形式，
而C标准并未规定编译器在一个表达式中何时进行自增运算，故结果可能是5*5(先把a取出，最后进行两次自增），也可能是（5*6）（先取出第一个a，自增后取出第二个a），输出25说明你的编译器采用了前面那种方式罢了。一个表达式中多个自增运算与编译器有关。
所以建议不要在同一个表达式中对同一变量施行多次自增运算

